<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>Template 10 Help</title>
</head>
<body style="font-family: 'Segoe UI'; margin: 20px auto 20px auto; width: 800px;">
    <table cellpadding="10">
        <tr>
            <td width="50%" valign="top">
                <h3>Template 10 Help</h3>
                <h1>The Models folder</h1>
                <ul>Models are simple classes that hold data. It is very unusual that a Model has any other functionality (methods or events).</ul>
            </td>
            <td width="50%"></td>
        </tr>
        <tr>
            <td valign="top">
                <h2>What's a Model?</h2>
                <p>
                    Most applications use data. It could be a User profile or a Todo item. The record can be persisted in a database or
                    a file - that is up to the developer. But software needs to represent data as a [class]. It could be in a User
                    class or a Todo [class]. This [class] structure is the only way an application can use data. It is the only way it
                    can be loaded into memory. It is up to the developer to figure out how to take the data from their database or
                    file and fill the [class].
                </p>
                <p>
                    Frameworks like Entity Framework can take a database record and put it in a [class]. Other technologies, like
                    JSON deserialization can take the JSON emitted by a REST service (which is only a string) and populate a [class]
                    with it. Whatever method a developer chooses does not matter, data just needs to be represented as a [class].
                </p>
                <h3>INotifyPropertyChanged</h3>
                <p>
                    In XAML data binding, developers can bind properties of a [UIElement] to a Model (which is a [class]).
                    The data binding framework recognizes a [class] and knows how to read its properties and present their values
                    in the user interface. For example, a developer might data bind the FirstName property of the User [class] to
                    the [Text] property of a XAML [TextBlock]. This would present the FirstName to in the user interface.
                </p>
                <p>
                    XAML can data bind in three ways, called modes. [OneTime] binding reads the value of the property when the
                    interface is initially rendered, but never reads it again. The other two, [OneWay] and [TwoWay] binding both
                    require the class implements [INotifyPropertyChanged] so the [PropertyChanged] event is raised when property
                    values change.
                </p>
                <p>
                    This event is not raised automatically. The developer must raise the event manually in the
                    setter of the property. Because of this, bindable properties cannot leverage the automatic property
                    implementation syntax in C#, which looks like: <span style="font-family: 'Courier New';">public String FirstName { get; set; } = String.Empty</span>.
                    There has been talk about extending the compiler to support [INotifyPropertyChange] with a simple
                    property attribute, but it is not part of C# 6 or VS 2015.
                </p>
                <h3>One implementation</h3>
                <p>
                    The implementation of [INotifyPropertyChanged] is quite redundant because a developer would implement it
                    about the same way in every Model. Because of this, the implementation is wrapped up in another class and
                    used as the abstract based of every Model. This abstract base is called BindableBase and is located in
                    the BindableBase.cs file in the project's Mvvm folder. This abstract base is the same in every project
                    and many MVVM frameworks ship their own version (which is fundamentally identical).
                </p>
            </td>
            <td valign="top" style="background-color: palegoldenrod;">
                <h2>This folder</h2>
                <p>
                    The following files represent the types used to implement the PushTriggerSample functionality in this template.
                    Each of the types in this folder are inside the [PushTriggerSample.Models] namespace.
                </p>
                <ol start="1">
                    <li><b>States.cs</b></li>
                </ol>
                <p>
                    A TodoItem can be in one of thre states: NotStarted, InProcess, and Done. These states are defined in
                    the States ENUM which resides in the [States.cs] file in this folder. Developers use an ENUM to constrain
                    the possible values of a property to a set list.
                </p>
                <ol start="2">
                    <li><b>TodoItem.cs</b></li>
                </ol>
                <p>
                    A PushTriggerSample list contains zero or more tasks. In this application, we call those TodoItems. This is a class
                    that has the task's Title, as well as other properties like State and DueDate. A TodoItem is intended to
                    be a member of a TodoList.
                </p>
                <ol start="3">
                    <li><b>TodoList.cs</b></li>
                </ol>
                <p>
                    This PushTriggerSample application allows the user to create more than one TodoList. For example, the user might create
                    a "grocery" PushTriggerSample list and a "vacation" PushTriggerSample list. A TodoItem can be the child of only one TodoList. And,
                    A TodoList can have any number of TodoItems as children.
                </p>
            </td>
        </tr>
    </table>
    <h3>//End</h3>
</body>
</html>